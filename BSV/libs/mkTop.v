//
// Generated by Bluespec Compiler, version untagged-g23254fbc (build 23254fbc)
//
// On Thu Apr 17 11:51:26 AEST 2025
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTop(CLK,
	     RST_N);
  input  CLK;
  input  RST_N;

  // inlined wires
  wire par_blocks_1_fired_1_whas,
       par_blocks_1_start_wire_whas,
       par_blocks_start_wire_whas,
       par_running_whas,
       start_wire_whas,
       state_set_pw_whas;

  // register cycle
  reg [13 : 0] cycle;
  wire [13 : 0] cycle_D_IN;
  wire cycle_EN;

  // register expect_result
  reg [31 : 0] expect_result;
  wire [31 : 0] expect_result_D_IN;
  wire expect_result_EN;

  // register m_active
  reg m_active;
  wire m_active_D_IN, m_active_EN;

  // register m_counter
  reg [7 : 0] m_counter;
  wire [7 : 0] m_counter_D_IN;
  wire m_counter_EN;

  // register m_inputs_reg
  reg [127 : 0] m_inputs_reg;
  wire [127 : 0] m_inputs_reg_D_IN;
  wire m_inputs_reg_EN;

  // register m_result_reg
  reg [31 : 0] m_result_reg;
  wire [31 : 0] m_result_reg_D_IN;
  wire m_result_reg_EN;

  // register par_blocks_1_fired
  reg par_blocks_1_fired;
  wire par_blocks_1_fired_D_IN, par_blocks_1_fired_EN;

  // register par_blocks_1_start_reg
  reg par_blocks_1_start_reg;
  wire par_blocks_1_start_reg_D_IN, par_blocks_1_start_reg_EN;

  // register par_blocks_fired
  reg par_blocks_fired;
  wire par_blocks_fired_D_IN, par_blocks_fired_EN;

  // register par_blocks_start_reg
  reg par_blocks_start_reg;
  wire par_blocks_start_reg_D_IN, par_blocks_start_reg_EN;

  // register running
  reg running;
  wire running_D_IN, running_EN;

  // register start_reg
  reg start_reg;
  wire start_reg_D_IN, start_reg_EN;

  // register start_reg_1
  reg start_reg_1;
  wire start_reg_1_D_IN, start_reg_1_EN;

  // register state_can_overlap
  reg state_can_overlap;
  wire state_can_overlap_D_IN, state_can_overlap_EN;

  // register state_fired
  reg state_fired;
  wire state_fired_D_IN, state_fired_EN;

  // register state_mkFSMstate
  reg [3 : 0] state_mkFSMstate;
  reg [3 : 0] state_mkFSMstate_D_IN;
  wire state_mkFSMstate_EN;

  // register test_input_0
  reg [31 : 0] test_input_0;
  wire [31 : 0] test_input_0_D_IN;
  wire test_input_0_EN;

  // register test_input_1
  reg [31 : 0] test_input_1;
  wire [31 : 0] test_input_1_D_IN;
  wire test_input_1_EN;

  // register test_input_2
  reg [31 : 0] test_input_2;
  wire [31 : 0] test_input_2_D_IN;
  wire test_input_2_EN;

  // register test_input_3
  reg [31 : 0] test_input_3;
  wire [31 : 0] test_input_3_D_IN;
  wire test_input_3_EN;

  // register testv
  reg [63 : 0] testv;
  wire [63 : 0] testv_D_IN;
  wire testv_EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_action_f_update_l26c9,
       WILL_FIRE_RL_action_l25c17,
       WILL_FIRE_RL_action_l27c13,
       WILL_FIRE_RL_action_l36c18,
       WILL_FIRE_RL_action_l41c17,
       WILL_FIRE_RL_action_l42c18,
       WILL_FIRE_RL_action_l47c9,
       WILL_FIRE_RL_actionpar_run_l35c13,
       WILL_FIRE_RL_actionpar_start_l35c13,
       WILL_FIRE_RL_fsm_start,
       WILL_FIRE_RL_idle_l24c17,
       WILL_FIRE_RL_m_clear_done;

  // inputs to muxes for submodule ports
  wire [13 : 0] MUX_cycle_write_1__VAL_1;
  wire [7 : 0] MUX_m_counter_write_1__VAL_2;
  wire MUX_start_reg_write_1__SEL_2;

  // declarations used by system tasks
  // synopsys translate_off
  reg TASK_valueplusargs___d164;
  reg TASK_valueplusargs___d166;
  reg TASK_valueplusargs___d168;
  reg Task__value_plusargs__avValue1;
  reg [31 : 0] x__h28692;
  reg [31 : 0] x__h28801;
  reg [31 : 0] x__h28910;
  reg [31 : 0] x__h29019;
  // synopsys translate_on

  // remaining internal signals
  wire [31 : 0] y__h31306, y__h31326, y__h365, y__h397;
  wire NOT_par_blocks_1_start_reg_8_6_OR_par_blocks_1_ETC___d108,
       NOT_par_blocks_1_start_reg_8_6_OR_par_blocks_1_ETC___d116,
       abort_whas__8_AND_abort_wget__9_0_OR_state_mkF_ETC___d154,
       cycle_5_ULT_10000___d86,
       expect_result_05_EQ_m_result_reg_06___d107;

  // rule RL_actionpar_start_l35c13
  assign WILL_FIRE_RL_actionpar_start_l35c13 =
	     (!par_blocks_1_start_reg || par_blocks_1_fired) &&
	     (!par_blocks_start_reg || par_blocks_fired) &&
	     state_mkFSMstate == 4'd3 ;

  // rule RL_action_l41c17
  assign WILL_FIRE_RL_action_l41c17 =
	     m_active && m_counter == 8'd0 &&
	     NOT_par_blocks_1_start_reg_8_6_OR_par_blocks_1_ETC___d108 &&
	     (state_mkFSMstate == 4'd4 || state_mkFSMstate == 4'd5) ;

  // rule RL_action_l42c18
  assign WILL_FIRE_RL_action_l42c18 =
	     m_active && m_counter == 8'd0 &&
	     NOT_par_blocks_1_start_reg_8_6_OR_par_blocks_1_ETC___d116 &&
	     (state_mkFSMstate == 4'd4 || state_mkFSMstate == 4'd5) ;

  // rule RL_action_f_update_l26c9
  assign WILL_FIRE_RL_action_f_update_l26c9 =
	     state_mkFSMstate == 4'd7 || state_mkFSMstate == 4'd8 ;

  // rule RL_action_l47c9
  assign WILL_FIRE_RL_action_l47c9 =
	     !cycle_5_ULT_10000___d86 &&
	     (state_mkFSMstate == 4'd2 || state_mkFSMstate == 4'd9) ;

  // rule RL_actionpar_run_l35c13
  assign WILL_FIRE_RL_actionpar_run_l35c13 =
	     (par_blocks_1_start_reg && !par_blocks_1_fired ||
	      par_blocks_start_reg && !par_blocks_fired) &&
	     (state_mkFSMstate == 4'd4 || state_mkFSMstate == 4'd5) ;

  // rule RL_fsm_start
  assign WILL_FIRE_RL_fsm_start =
	     abort_whas__8_AND_abort_wget__9_0_OR_state_mkF_ETC___d154 &&
	     start_reg ;

  // rule RL_action_l25c17
  assign WILL_FIRE_RL_action_l25c17 =
	     start_wire_whas &&
	     (state_mkFSMstate == 4'd0 || state_mkFSMstate == 4'd10) ;

  // rule RL_idle_l24c17
  assign WILL_FIRE_RL_idle_l24c17 =
	     !start_wire_whas && state_mkFSMstate == 4'd10 ;

  // rule RL_m_clear_done
  assign WILL_FIRE_RL_m_clear_done = m_counter == 8'd0 && m_active ;

  // rule RL_action_l36c18
  assign WILL_FIRE_RL_action_l36c18 =
	     !m_active && par_blocks_start_wire_whas && par_running_whas ;

  // rule RL_action_l27c13
  assign WILL_FIRE_RL_action_l27c13 =
	     cycle_5_ULT_10000___d86 &&
	     (state_mkFSMstate == 4'd2 || state_mkFSMstate == 4'd9) ;

  // inputs to muxes for submodule ports
  assign MUX_start_reg_write_1__SEL_2 =
	     abort_whas__8_AND_abort_wget__9_0_OR_state_mkF_ETC___d154 &&
	     !start_reg &&
	     !running ;
  assign MUX_cycle_write_1__VAL_1 = cycle + 14'd1 ;
  assign MUX_m_counter_write_1__VAL_2 = m_counter - 8'd1 ;

  // inlined wires
  assign start_wire_whas =
	     WILL_FIRE_RL_fsm_start || start_reg_1 && !state_fired ;
  assign par_running_whas =
	     WILL_FIRE_RL_actionpar_run_l35c13 ||
	     WILL_FIRE_RL_actionpar_start_l35c13 ;
  assign par_blocks_start_wire_whas =
	     par_blocks_start_reg && !par_blocks_fired ||
	     WILL_FIRE_RL_actionpar_start_l35c13 ;
  assign par_blocks_1_start_wire_whas =
	     par_blocks_1_start_reg && !par_blocks_1_fired ||
	     WILL_FIRE_RL_actionpar_start_l35c13 ;
  assign par_blocks_1_fired_1_whas =
	     par_blocks_1_start_wire_whas && par_running_whas ;
  assign state_set_pw_whas =
	     WILL_FIRE_RL_idle_l24c17 || WILL_FIRE_RL_actionpar_run_l35c13 ||
	     WILL_FIRE_RL_action_l47c9 ||
	     WILL_FIRE_RL_action_f_update_l26c9 ||
	     WILL_FIRE_RL_action_l42c18 ||
	     WILL_FIRE_RL_action_l41c17 ||
	     WILL_FIRE_RL_actionpar_start_l35c13 ||
	     WILL_FIRE_RL_action_l27c13 ||
	     state_mkFSMstate == 4'd1 ||
	     WILL_FIRE_RL_action_l25c17 ;

  // register cycle
  assign cycle_D_IN =
	     WILL_FIRE_RL_action_f_update_l26c9 ?
	       MUX_cycle_write_1__VAL_1 :
	       14'd0 ;
  assign cycle_EN =
	     WILL_FIRE_RL_action_f_update_l26c9 || state_mkFSMstate == 4'd1 ;

  // register expect_result
  assign expect_result_D_IN = test_input_0 + y__h31306 ;
  assign expect_result_EN = par_blocks_1_fired_1_whas ;

  // register m_active
  assign m_active_D_IN = !WILL_FIRE_RL_m_clear_done ;
  assign m_active_EN =
	     WILL_FIRE_RL_m_clear_done || WILL_FIRE_RL_action_l36c18 ;

  // register m_counter
  assign m_counter_D_IN =
	     WILL_FIRE_RL_action_l36c18 ?
	       8'd2 :
	       MUX_m_counter_write_1__VAL_2 ;
  assign m_counter_EN = m_counter != 8'd0 || WILL_FIRE_RL_action_l36c18 ;

  // register m_inputs_reg
  assign m_inputs_reg_D_IN =
	     { test_input_3, test_input_2, test_input_1, test_input_0 } ;
  assign m_inputs_reg_EN = WILL_FIRE_RL_action_l36c18 ;

  // register m_result_reg
  assign m_result_reg_D_IN = m_inputs_reg[31:0] + y__h365 ;
  assign m_result_reg_EN = m_counter != 8'd0 ;

  // register par_blocks_1_fired
  assign par_blocks_1_fired_D_IN = par_blocks_1_fired_1_whas ;
  assign par_blocks_1_fired_EN = 1'd1 ;

  // register par_blocks_1_start_reg
  assign par_blocks_1_start_reg_D_IN = par_blocks_1_start_wire_whas ;
  assign par_blocks_1_start_reg_EN = 1'd1 ;

  // register par_blocks_fired
  assign par_blocks_fired_D_IN = WILL_FIRE_RL_action_l36c18 ;
  assign par_blocks_fired_EN = 1'd1 ;

  // register par_blocks_start_reg
  assign par_blocks_start_reg_D_IN = par_blocks_start_wire_whas ;
  assign par_blocks_start_reg_EN = 1'd1 ;

  // register running
  assign running_D_IN = 1'd1 ;
  assign running_EN = MUX_start_reg_write_1__SEL_2 ;

  // register start_reg
  assign start_reg_D_IN = !WILL_FIRE_RL_fsm_start ;
  assign start_reg_EN =
	     WILL_FIRE_RL_fsm_start ||
	     abort_whas__8_AND_abort_wget__9_0_OR_state_mkF_ETC___d154 &&
	     !start_reg &&
	     !running ;

  // register start_reg_1
  assign start_reg_1_D_IN = start_wire_whas ;
  assign start_reg_1_EN = 1'd1 ;

  // register state_can_overlap
  assign state_can_overlap_D_IN = state_set_pw_whas || state_can_overlap ;
  assign state_can_overlap_EN = 1'd1 ;

  // register state_fired
  assign state_fired_D_IN = state_set_pw_whas ;
  assign state_fired_EN = 1'd1 ;

  // register state_mkFSMstate
  always@(WILL_FIRE_RL_idle_l24c17 or
	  WILL_FIRE_RL_action_l25c17 or
	  state_mkFSMstate or
	  WILL_FIRE_RL_action_l27c13 or
	  WILL_FIRE_RL_actionpar_start_l35c13 or
	  WILL_FIRE_RL_actionpar_run_l35c13 or
	  WILL_FIRE_RL_action_l41c17 or
	  WILL_FIRE_RL_action_l42c18 or
	  WILL_FIRE_RL_action_f_update_l26c9 or WILL_FIRE_RL_action_l47c9)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_idle_l24c17: state_mkFSMstate_D_IN = 4'd0;
      WILL_FIRE_RL_action_l25c17: state_mkFSMstate_D_IN = 4'd1;
      state_mkFSMstate == 4'd1: state_mkFSMstate_D_IN = 4'd2;
      WILL_FIRE_RL_action_l27c13: state_mkFSMstate_D_IN = 4'd3;
      WILL_FIRE_RL_actionpar_start_l35c13: state_mkFSMstate_D_IN = 4'd4;
      WILL_FIRE_RL_actionpar_run_l35c13: state_mkFSMstate_D_IN = 4'd5;
      WILL_FIRE_RL_action_l41c17: state_mkFSMstate_D_IN = 4'd7;
      WILL_FIRE_RL_action_l42c18: state_mkFSMstate_D_IN = 4'd8;
      WILL_FIRE_RL_action_f_update_l26c9: state_mkFSMstate_D_IN = 4'd9;
      WILL_FIRE_RL_action_l47c9: state_mkFSMstate_D_IN = 4'd10;
      default: state_mkFSMstate_D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign state_mkFSMstate_EN =
	     WILL_FIRE_RL_idle_l24c17 || WILL_FIRE_RL_action_l25c17 ||
	     state_mkFSMstate == 4'd1 ||
	     WILL_FIRE_RL_action_l27c13 ||
	     WILL_FIRE_RL_actionpar_start_l35c13 ||
	     WILL_FIRE_RL_actionpar_run_l35c13 ||
	     WILL_FIRE_RL_action_l41c17 ||
	     WILL_FIRE_RL_action_l42c18 ||
	     WILL_FIRE_RL_action_f_update_l26c9 ||
	     WILL_FIRE_RL_action_l47c9 ;

  // register test_input_0
  assign test_input_0_D_IN = x__h28692 ;
  assign test_input_0_EN = WILL_FIRE_RL_action_l27c13 ;

  // register test_input_1
  assign test_input_1_D_IN = x__h28801 ;
  assign test_input_1_EN = WILL_FIRE_RL_action_l27c13 ;

  // register test_input_2
  assign test_input_2_D_IN = x__h28910 ;
  assign test_input_2_EN = WILL_FIRE_RL_action_l27c13 ;

  // register test_input_3
  assign test_input_3_D_IN = x__h29019 ;
  assign test_input_3_EN = WILL_FIRE_RL_action_l27c13 ;

  // register testv
  assign testv_D_IN = 64'h0 ;
  assign testv_EN = 1'b0 ;

  // remaining internal signals
  assign NOT_par_blocks_1_start_reg_8_6_OR_par_blocks_1_ETC___d108 =
	     (!par_blocks_1_start_reg || par_blocks_1_fired) &&
	     (!par_blocks_start_reg || par_blocks_fired) &&
	     expect_result_05_EQ_m_result_reg_06___d107 ;
  assign NOT_par_blocks_1_start_reg_8_6_OR_par_blocks_1_ETC___d116 =
	     (!par_blocks_1_start_reg || par_blocks_1_fired) &&
	     (!par_blocks_start_reg || par_blocks_fired) &&
	     !expect_result_05_EQ_m_result_reg_06___d107 ;
  assign abort_whas__8_AND_abort_wget__9_0_OR_state_mkF_ETC___d154 =
	     (state_mkFSMstate == 4'd0 || state_mkFSMstate == 4'd10) &&
	     (!start_reg_1 || state_fired) ;
  assign cycle_5_ULT_10000___d86 = cycle < 14'd10000 ;
  assign expect_result_05_EQ_m_result_reg_06___d107 =
	     expect_result == m_result_reg ;
  assign y__h31306 = test_input_1 + y__h31326 ;
  assign y__h31326 = test_input_2 + test_input_3 ;
  assign y__h365 = m_inputs_reg[63:32] + y__h397 ;
  assign y__h397 = m_inputs_reg[95:64] + m_inputs_reg[127:96] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_active <= `BSV_ASSIGNMENT_DELAY 1'd0;
	m_counter <= `BSV_ASSIGNMENT_DELAY 8'd0;
	par_blocks_1_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	par_blocks_1_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	par_blocks_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	par_blocks_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	running <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (m_active_EN) m_active <= `BSV_ASSIGNMENT_DELAY m_active_D_IN;
	if (m_counter_EN) m_counter <= `BSV_ASSIGNMENT_DELAY m_counter_D_IN;
	if (par_blocks_1_fired_EN)
	  par_blocks_1_fired <= `BSV_ASSIGNMENT_DELAY par_blocks_1_fired_D_IN;
	if (par_blocks_1_start_reg_EN)
	  par_blocks_1_start_reg <= `BSV_ASSIGNMENT_DELAY
	      par_blocks_1_start_reg_D_IN;
	if (par_blocks_fired_EN)
	  par_blocks_fired <= `BSV_ASSIGNMENT_DELAY par_blocks_fired_D_IN;
	if (par_blocks_start_reg_EN)
	  par_blocks_start_reg <= `BSV_ASSIGNMENT_DELAY
	      par_blocks_start_reg_D_IN;
	if (running_EN) running <= `BSV_ASSIGNMENT_DELAY running_D_IN;
	if (start_reg_EN) start_reg <= `BSV_ASSIGNMENT_DELAY start_reg_D_IN;
	if (start_reg_1_EN)
	  start_reg_1 <= `BSV_ASSIGNMENT_DELAY start_reg_1_D_IN;
	if (state_can_overlap_EN)
	  state_can_overlap <= `BSV_ASSIGNMENT_DELAY state_can_overlap_D_IN;
	if (state_fired_EN)
	  state_fired <= `BSV_ASSIGNMENT_DELAY state_fired_D_IN;
	if (state_mkFSMstate_EN)
	  state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY state_mkFSMstate_D_IN;
      end
    if (cycle_EN) cycle <= `BSV_ASSIGNMENT_DELAY cycle_D_IN;
    if (expect_result_EN)
      expect_result <= `BSV_ASSIGNMENT_DELAY expect_result_D_IN;
    if (m_inputs_reg_EN)
      m_inputs_reg <= `BSV_ASSIGNMENT_DELAY m_inputs_reg_D_IN;
    if (m_result_reg_EN)
      m_result_reg <= `BSV_ASSIGNMENT_DELAY m_result_reg_D_IN;
    if (test_input_0_EN)
      test_input_0 <= `BSV_ASSIGNMENT_DELAY test_input_0_D_IN;
    if (test_input_1_EN)
      test_input_1 <= `BSV_ASSIGNMENT_DELAY test_input_1_D_IN;
    if (test_input_2_EN)
      test_input_2 <= `BSV_ASSIGNMENT_DELAY test_input_2_D_IN;
    if (test_input_3_EN)
      test_input_3 <= `BSV_ASSIGNMENT_DELAY test_input_3_D_IN;
    if (testv_EN) testv <= `BSV_ASSIGNMENT_DELAY testv_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cycle = 14'h2AAA;
    expect_result = 32'hAAAAAAAA;
    m_active = 1'h0;
    m_counter = 8'hAA;
    m_inputs_reg = 128'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    m_result_reg = 32'hAAAAAAAA;
    par_blocks_1_fired = 1'h0;
    par_blocks_1_start_reg = 1'h0;
    par_blocks_fired = 1'h0;
    par_blocks_start_reg = 1'h0;
    running = 1'h0;
    start_reg = 1'h0;
    start_reg_1 = 1'h0;
    state_can_overlap = 1'h0;
    state_fired = 1'h0;
    state_mkFSMstate = 4'hA;
    test_input_0 = 32'hAAAAAAAA;
    test_input_1 = 32'hAAAAAAAA;
    test_input_2 = 32'hAAAAAAAA;
    test_input_3 = 32'hAAAAAAAA;
    testv = 64'hAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l41c17) $display("\033[32mTest passed\033[0m");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l42c18)
	$display("\033[31mTest failed\033[0m, expected = %0x, got = %0x",
		 expect_result,
		 m_result_reg);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l42c18)
	begin
	  $display;
	  $finish(32'd1);
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l47c9) $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_actionpar_start_l35c13 &&
	  (WILL_FIRE_RL_action_l41c17 || WILL_FIRE_RL_action_l42c18 ||
	   WILL_FIRE_RL_action_f_update_l26c9 ||
	   WILL_FIRE_RL_action_l47c9))
	$display("Error: \"mkTop.bsv\", line 35, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_actionpar_start_l35c13] and\n  [RL_action_l41c17, RL_action_l42c18, RL_action_f_update_l26c9,\n  RL_action_l47c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l41c17 &&
	  (WILL_FIRE_RL_action_l42c18 || WILL_FIRE_RL_action_f_update_l26c9 ||
	   WILL_FIRE_RL_action_l47c9))
	$display("Error: \"mkTop.bsv\", line 41, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l41c17] and\n  [RL_action_l42c18, RL_action_f_update_l26c9, RL_action_l47c9] ) fired in the\n  same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l42c18 &&
	  (WILL_FIRE_RL_action_f_update_l26c9 || WILL_FIRE_RL_action_l47c9))
	$display("Error: \"mkTop.bsv\", line 42, column 18: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l42c18] and\n  [RL_action_f_update_l26c9, RL_action_l47c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_f_update_l26c9 && WILL_FIRE_RL_action_l47c9)
	$display("Error: \"mkTop.bsv\", line 26, column 69: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_f_update_l26c9] and\n  [RL_action_l47c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (running &&
	  abort_whas__8_AND_abort_wget__9_0_OR_state_mkF_ETC___d154 &&
	  !start_reg)
	$finish(32'd0);
    begin
      TASK_valueplusargs___d164 = $value$plusargs("testv=%d", testv);
      #0;
    end
    if (TASK_valueplusargs___d164) $display("testv = %0x", testv);
    if (!TASK_valueplusargs___d164) $display("testv not valid");
    begin
      TASK_valueplusargs___d166 = $value$plusargs("testb=%b", testv);
      #0;
    end
    if (TASK_valueplusargs___d166) $display("testv = %0x", testv);
    if (!TASK_valueplusargs___d166) $display("testv not valid");
    begin
      TASK_valueplusargs___d168 = $value$plusargs("testS=%s", testv);
      #0;
    end
    if (TASK_valueplusargs___d168) $display("testv = %s", testv);
    if (!TASK_valueplusargs___d168) $display("testv not valid");
    begin
      Task__value_plusargs__avValue1 = $value$plusargs("testF=%f", testv);
      #0;
    end
    $display("testv F = %02f", testv);
    $finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13) $display("Cycle %0d", cycle);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13)
	begin
	  x__h28692 = $random;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13) $display("random %0x", x__h28692);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13)
	begin
	  x__h28801 = $random;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13) $display("random %0x", x__h28801);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13)
	begin
	  x__h28910 = $random;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13) $display("random %0x", x__h28910);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13)
	begin
	  x__h29019 = $random;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13) $display("random %0x", x__h29019);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l25c17 &&
	  (state_mkFSMstate == 4'd1 || WILL_FIRE_RL_action_l27c13 ||
	   WILL_FIRE_RL_actionpar_start_l35c13 ||
	   WILL_FIRE_RL_action_l41c17 ||
	   WILL_FIRE_RL_action_l42c18 ||
	   WILL_FIRE_RL_action_f_update_l26c9 ||
	   WILL_FIRE_RL_action_l47c9))
	$display("Error: \"mkTop.bsv\", line 25, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l25c17] and\n  [RL_action_f_init_l26c9, RL_action_l27c13, RL_actionpar_start_l35c13,\n  RL_action_l41c17, RL_action_l42c18, RL_action_f_update_l26c9,\n  RL_action_l47c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (state_mkFSMstate == 4'd1 &&
	  (WILL_FIRE_RL_action_l27c13 ||
	   WILL_FIRE_RL_actionpar_start_l35c13 ||
	   WILL_FIRE_RL_action_l41c17 ||
	   WILL_FIRE_RL_action_l42c18 ||
	   WILL_FIRE_RL_action_f_update_l26c9 ||
	   WILL_FIRE_RL_action_l47c9))
	$display("Error: \"mkTop.bsv\", line 26, column 18: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_f_init_l26c9] and\n  [RL_action_l27c13, RL_actionpar_start_l35c13, RL_action_l41c17,\n  RL_action_l42c18, RL_action_f_update_l26c9, RL_action_l47c9] ) fired in the\n  same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l27c13 &&
	  (WILL_FIRE_RL_actionpar_start_l35c13 ||
	   WILL_FIRE_RL_action_l41c17 ||
	   WILL_FIRE_RL_action_l42c18 ||
	   WILL_FIRE_RL_action_f_update_l26c9 ||
	   WILL_FIRE_RL_action_l47c9))
	$display("Error: \"mkTop.bsv\", line 27, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l27c13] and\n  [RL_actionpar_start_l35c13, RL_action_l41c17, RL_action_l42c18,\n  RL_action_f_update_l26c9, RL_action_l47c9] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkTop

